\section{CASO DE USO: ÁRVORE BINÁRIA DE PESQUISA}

O Código \ref{listing:abp} abaixo demonstra a instanciação de uma árvore binária de pesquisa, os detalhes da implementação
serão discutidos adiante. O objetivo em um primeiro momento é demonstrar a facilidade de usar implementações funcionais
sobre a árvore afim de realizar algumas operações mais comuns.

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    from Btree import BinaryTree, Node
    from toolz import compose, compose_left
    
    tree = BinaryTree([ 5, 2, 6, 10, 1, 3, 4, 9 ])
    \end{minted}
    \caption{Árvore Binária de Pesquisa}
    \label{listing:abp}
\end{listing}

Nota-se na linha 4 que a árvore \textbf{tree} é criada a partir de uma lista de inteiros. O objetivo
é analisar as chamadas e usos de funções sobre operações comuns desta estrutura de dados, tais como:

\begin{enumerate}
    \item Percorrimento da árvore em ordem
    \item Uso da Busca em Profundidade, do inglês: \textit{Depth First Search} (DFS)\footnote{
        Algoritmo de exploração de grafos que percorre ramificações até o fim antes de retroceder (backtracking). Usado em árvores, grafos e labirintos – estudado desde o século XIX por Trémaux (\citeauthor{wiki_dfs}, \citeyear{wiki_dfs})\cite{wiki_dfs}.
    }, para obter informações, como:
    \begin{enumerate}
        \item Checar a presença de um determinado nó na árvore
        \item Listar os nós folha da árvore
        \item Percorrer determinado nó até a raiz
        \item Calcular a altura da árvore
        \item Calcular o balanceamento da árvore
    \end{enumerate}
\end{enumerate}

\subsection{Usos}
\subsubsection{Percorrimento em ordem}
Conforme mostrado no Código \ref{listing:abp}, a árvore binária é incializada com uma lista de inteiros totalmente desordenada.
Um dos usos mais comuns da Árvore Binária são os percorrimentos em:
\begin{itemize}
    \item\textbf{Pré-Ordem}
    \item\textbf{Em-Ordem}
    \item\textbf{Pós-Ordem}
\end{itemize}

O percorrimento \textbf{Em-Ordem} pode ser utilizado para percorrer todos os nós da árvore de forma que os nós mais à esquerda são visitados primeiro. Dada a natureza de inserção dos itens em uma Árvore Binária,
sabe-se que os items cujos valores sejam menores estarão à esquerda, ao passo que os maiores à direita. Desta forma, pode-se imprimir a lista totalmente ordenada conforme mostrado no Côdigo \ref{listing:abp-in-order}:

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    tree.inOrderWalk(lambda node: print(node.value, end=" "))
    # Saída: 1 2 3 4 5 6 9 10 
    \end{minted}
    \caption{Percorrimento em ordem}
    \label{listing:abp-in-order}
\end{listing}

Nota-se no código \ref{listing:abp-in-order} o nível de abstração quando aplicada a programação funcional, pois a medida que o percorrimento ocorre, cada nó encontrado chama a funçåo lambda\footnote{
    Explicar a função lambda
} passada como segundo parâmetro de \textbf{inOrderWalk}. A função então desempenha o papel de imprimir o valor do nó
Observa-se que ao contrário de simplesmente imprimir o nó, poderia fazer-se qualquer outra operação com o mesmo, como empilhá-los para formar uma nova lista
ordenada, por exemplo.

\subsubsection{Depth First Search (DFS)}

A Busca em profundidade (\textit{Depth First Search}) é um algoritmo que também percorre os nós de uma árvore, assim como o percorrimento em ordem.
Mas diferente de percorrer em ordem, segundo \citeauthor{wiki_dfs}\cite{wiki_dfs}: A Busca em profundidade é uma busca não-informada que progride se
aprofundando tanto quanto possível a partir do primeiro nó filho. Quando a busca chega a um nó folha, retroage-se até o próximo nó e a busca e começa
novamente.
O Código \ref{listing:dfs-percorrer} mostra o percorrimento utilizando DFS.

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    tree.dfs(lambda node: print(node.value, end=" "))
    # Saída: 5 2 1 3 4 6 10 9 
    \end{minted}
    \caption{DFS: Percorrimento}
    \label{listing:dfs-percorrer}
\end{listing}

Nota-se que o resultado apresentado agora é diferente do percorrimento em ordem apresentado no Código \ref{listing:abp-in-order}.
A busca começa a partir do nó raiz e segue até o último nó folha. Evidentemente, os valores impressos não são exibidos de forma ordenada.

\subsubsection{DFS: Encontrar um nó}

A função passada como argumento para \textbf{dfs}, ao contrário das já apresentadas, espera um valor booleano de retorno.
Este valor é utilizado para controlar quando parar a busca dfs. Caso uma chamada à função passada a \textbf{dfs}
retorne o valor \textbf{True}, a busca é interrompida. Quando \textbf{False}, a busca procede.\linebreak
O Código \ref{listing:dfs-encontra-no-funcoes} mostra a definição de duas funções nas linhas 1 e 2 para serem
utilizadas na \textbf{dfs}:

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    def retorna_verdadeiro(node: Node): print("Nó visitado:", node); return True
    def encontre_no(node_number: int):
        def closure(node: Node): print("Nó visitado:", node); return node.value == node_number
        return closure
    \end{minted}
    \caption{DFS: Funções de busca}
    \label{listing:dfs-encontra-no-funcoes}
\end{listing}
A função \textbf{retorna\_verdadeiro} apenas exibe o nó visitado e imediatamente retorna \textbf{True}. Enquanto que \textbf{encontre\_no}
retorna uma \textit{Closure}\footnote{
    Explicar closure
}
que compara o nó atual com um valor passado como argumento. Desta forma, \textbf{encontre\_no} se utiliza de DFS para procurar um nó na árvore.\linebreak
Conforme se observa no Código \ref{listing:dfs-encontra-no-verdadeiro}, apenas o nó raiz é visitado pois \textbf{retorna\_verdadeiro} imediatemente retorna
o valor \textbf{True}. Quando uma função retorna \textbf{True}, a \textbf{dfs} retorna o nó atual que está sendo visitado:

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    tree.dfs(retorna_verdadeiro)
    # Saída: Nó visitado: Node(5)
    # Saída: 
    # Saída: Node(5)
    \end{minted}
    \caption{DFS: retorna_verdadeiro}
    \label{listing:dfs-encontra-no-verdadeiro}
\end{listing}

No Código \ref{listing:dfs-encontra-no-1} pode-se observar que mais nós são visitados. Ao final, depois de percorrer
os nós $5,2,1$, finalmente é retornado o nó $1$ por ele ter sido encontrado.

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    tree.dfs(encontre_no(1))
    # Saída: Nó visitado: Node(5)
    # Saída: Nó visitado: Node(2)
    # Saída: Nó visitado: Node(1)
    # Saída: 
    # Saída: Node(1)
    \end{minted}
    \caption{DFS: encontre_no(1)}
    \label{listing:dfs-encontra-no-1}
\end{listing}

Finalmente, quando um determinado nó não é encontrado, a árvore inteira é percorrida conforme abaixo:

\begin{listing}[!ht]
    \begin{minted}[linenos,xleftmargin=2mm,tabsize=2,breaklines,autogobble,numbersep=5pt]{python}
    tree.dfs(encontre_no(11))
    # Saída: Nó visitado: Node(5)
    # Saída: Nó visitado: Node(2)
    # Saída: Nó visitado: Node(1)
    # Saída: Nó visitado: Node(3)
    # Saída: Nó visitado: Node(4)
    # Saída: Nó visitado: Node(6)
    # Saída: Nó visitado: Node(10)
    # Saída: Nó visitado: Node(9)
    \end{minted}
    \caption{DFS: encontre_no(11)}
    \label{listing:dfs-encontra-no-11}
\end{listing}

\subsubsection{DFS: Encontrar nós folha}

\subsection{Implementação}
\subsubsection{Node}
\subsubsection{BinaryTree}
